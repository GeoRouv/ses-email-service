# CLAUDE.md — Development Guide for SES Email Service

## Project Overview
Building a production-ready email delivery service using AWS SES. FastAPI backend with Jinja2 + Tailwind + Chart.js dashboard. PostgreSQL database with SQLAlchemy async ORM.

## Quick Reference

### Run the project
```bash
docker compose up -d            # Start Postgres + app
alembic upgrade head            # Run migrations
uvicorn app.main:app --reload   # Dev server on :8000
```

### Run tests
```bash
pytest                          # All tests
pytest --cov=app                # With coverage
pytest tests/test_email_service.py -v  # Single file
```

### Key URLs
- Swagger docs: http://localhost:8000/docs
- Dashboard: http://localhost:8000/dashboard
- Health check: http://localhost:8000/health

---

## Architecture Rules

### Layer Responsibilities
- **Routes** (`app/routes/`): HTTP concerns ONLY. Parse request, call service, return response. Never import `boto3` or `sqlalchemy` directly.
- **Services** (`app/services/`): ALL business logic lives here. Services receive a DB session and return data. They are the unit test target.
- **Models** (`app/models/`): SQLAlchemy ORM classes. No methods beyond `__repr__`. No business logic.
- **Schemas** (`app/schemas/`): Pydantic models for request validation and response serialization. Use `model_config = ConfigDict(from_attributes=True)` for ORM compatibility.
- **Utils** (`app/utils/`): Pure functions. No DB access, no side effects. Email validation, HTML processing, SNS signature verification.

### Dependency Injection Pattern
Use FastAPI's `Depends()` for DB sessions and services:
```python
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_session

@router.post("/api/emails/send")
async def send_email(
    request: SendEmailRequest,
    db: AsyncSession = Depends(get_session),
):
    result = await email_service.send(db, request)
    return result
```

### Error Response Format
ALL errors must follow this format — no exceptions:
```python
{
    "success": False,
    "error": {
        "code": "ERROR_CODE_IN_CAPS",   # Machine-readable
        "message": "Human-readable explanation",
        "details": {}                     # Optional context
    }
}
```

Use a shared `ErrorResponse` Pydantic model and a `raise_api_error()` helper that raises `HTTPException` with this structure.

---

## Database Conventions

### Naming
- Table names: **plural, snake_case** (`messages`, `click_events`)
- Columns: **snake_case** (`ses_message_id`, `created_at`)
- Foreign keys: `{singular_table}_id` (`message_id`)
- Indexes: `ix_{table}_{column}` (`ix_messages_status`)

### Common Columns
Every table gets:
```python
id = Column(UUID, primary_key=True, default=uuid4)
created_at = Column(DateTime(timezone=True), server_default=func.now())
```

### UUID Generation
Use Python `uuid.uuid4()` as default, not Postgres `gen_random_uuid()`. Keeps it portable for testing with SQLite.

### Async Session Management
```python
# database.py pattern
async def get_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_factory() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
```

### Migrations
```bash
alembic revision --autogenerate -m "description"  # Generate
alembic upgrade head                               # Apply
alembic downgrade -1                               # Rollback one
```
Always review autogenerated migrations before applying. Check that indexes are correct.

---

## AWS SES Patterns

### SES Client Wrapper (`app/services/ses_client.py`)
Centralize all boto3 calls. Use `aioboto3` for async:
```python
import aioboto3
from app.config import settings

class SESClient:
    def __init__(self):
        self.session = aioboto3.Session(
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_REGION,
        )

    async def send_email(self, source, to, subject, html, text, message_id, configuration_set):
        async with self.session.client("ses") as ses:
            response = await ses.send_email(
                Source=source,
                Destination={"ToAddresses": [to]},
                Message={
                    "Subject": {"Data": subject},
                    "Body": {
                        "Html": {"Data": html},
                        "Text": {"Data": text},
                    },
                },
                Tags=[{"Name": "MessageId", "Value": message_id}],
                ConfigurationSetName=configuration_set,
            )
            return response["MessageId"]
```

### SES Message ID Correlation
SES returns its own `MessageId` when sending (e.g., `0100018e...`). We also generate our own `msg_xxx` ID. Store BOTH:
- `id` (our UUID) — used in API responses, tracking URLs
- `ses_message_id` — used to correlate webhooks back to our record

The webhook's `mail.messageId` field matches the `ses_message_id`.

### SES Tags for Tracking
Pass our message ID as an SES tag so it appears in webhook payloads:
```python
Tags=[{"Name": "AppMessageId", "Value": str(message.id)}]
```
This provides a secondary correlation path if `ses_message_id` lookup fails.

### Configuration Set
Always use the provided configuration set (`ses-assessment-tracking`) so SES routes events to the SNS topic.

---

## SNS Webhook Processing

### SNS Message Structure (CRITICAL)
SNS wraps everything in an envelope. The SES event is JSON-stringified inside the `Message` field:
```python
# What arrives at POST /api/webhooks/ses:
{
    "Type": "Notification",            # or "SubscriptionConfirmation"
    "MessageId": "sns-msg-id",
    "TopicArn": "arn:aws:sns:...",
    "Message": "{\"eventType\":\"Delivery\",...}",  # ← THIS IS A STRING, parse it
    "Timestamp": "2024-01-15T10:30:00.000Z",
    "Signature": "...",
    "SigningCertURL": "https://sns.us-east-1.amazonaws.com/...",
    "SignatureVersion": "1"
}
```

Must `json.loads(body["Message"])` to get the actual SES event.

### SNS Signature Validation
1. Fetch the signing certificate from `SigningCertURL` (cache it)
2. Verify the URL is an SNS endpoint (`sns.{region}.amazonaws.com`)
3. Build the string to sign (specific field order depends on `Type`)
4. Verify signature using the certificate's public key

Use the `cryptography` library, NOT `M2Crypto` or `pyOpenSSL`.

### Subscription Confirmation
When SNS first subscribes, it sends a `SubscriptionConfirmation` message. Auto-confirm by fetching the `SubscribeURL`:
```python
if sns_message["Type"] == "SubscriptionConfirmation":
    async with httpx.AsyncClient() as client:
        await client.get(sns_message["SubscribeURL"])
    return {"status": "confirmed"}
```

### Event Type Routing
```python
event = json.loads(sns_message["Message"])
event_type = event.get("eventType")  # Note: camelCase from SES

handlers = {
    "Delivery": handle_delivery,
    "Bounce": handle_bounce,
    "Complaint": handle_complaint,
    "DeliveryDelay": handle_delay,
    "Reject": handle_reject,
}
handler = handlers.get(event_type)
if handler:
    await handler(db, event)
```

### SES Event Payload Shapes
```python
# Delivery
event["delivery"]["timestamp"]
event["delivery"]["recipients"]  # list of email addresses

# Bounce
event["bounce"]["bounceType"]    # "Permanent" or "Transient"
event["bounce"]["bouncedRecipients"][0]["diagnosticCode"]
# Map: "Permanent" → "hard", "Transient" → "soft"

# Complaint
event["complaint"]["complainedRecipients"]
event["complaint"]["complaintFeedbackType"]  # "abuse", "not-spam", etc.

# DeliveryDelay
event["deliveryDelay"]["delayType"]          # "InternalFailure", "General", "MailboxFull", etc.
event["deliveryDelay"]["delayedRecipients"]
event["deliveryDelay"]["timestamp"]

# Common: mail object (present in all events)
event["mail"]["messageId"]       # ← SES message ID for correlation
event["mail"]["tags"]            # ← Our custom tags
```

---

## Click & Open Tracking

### URL Rewriting (BeautifulSoup)
```python
from bs4 import BeautifulSoup
from urllib.parse import quote

def rewrite_urls(html: str, message_id: str, base_url: str) -> str:
    soup = BeautifulSoup(html, "html.parser")
    for a_tag in soup.find_all("a", href=True):
        original = a_tag["href"]
        if original.startswith(("mailto:", "#", "tel:")):
            continue
        encoded = quote(original, safe="")
        a_tag["href"] = f"{base_url}/api/track/click/{message_id}?url={encoded}"
    return str(soup)
```

### Tracking Pixel
```python
TRACKING_PIXEL_GIF = base64.b64decode(
    "R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
)

def inject_pixel(html: str, message_id: str, base_url: str) -> str:
    pixel_url = f"{base_url}/api/track/open/{message_id}"
    pixel_tag = f'<img src="{pixel_url}" width="1" height="1" alt="" style="display:none">'
    # Insert before </body> if exists, otherwise append
    if "</body>" in html.lower():
        return html.replace("</body>", f"{pixel_tag}</body>")
    return html + pixel_tag
```

### First-Open-Only Logic
```python
# In tracking_service.py
async def record_open(db: AsyncSession, message_id: str):
    message = await get_message(db, message_id)
    if message and message.opened_at is None:
        message.opened_at = datetime.utcnow()
        await db.flush()
```

---

## Unsubscribe Tokens

### Token Generation (PyJWT)
```python
import jwt
from datetime import datetime, timedelta
from app.config import settings

def generate_unsubscribe_token(email: str, message_id: str) -> str:
    payload = {
        "email": email,
        "message_id": str(message_id),
        "iat": datetime.utcnow(),
        "exp": datetime.utcnow() + timedelta(days=30),
    }
    return jwt.encode(payload, settings.UNSUBSCRIBE_SECRET, algorithm="HS256")

def validate_unsubscribe_token(token: str) -> dict | None:
    try:
        return jwt.decode(token, settings.UNSUBSCRIBE_SECRET, algorithms=["HS256"])
    except jwt.ExpiredSignatureError:
        return None
    except jwt.InvalidTokenError:
        return None
```

### Email Masking
```python
def mask_email(email: str) -> str:
    local, domain = email.split("@")
    masked_local = local[0] + "***" if len(local) > 1 else "***"
    return f"{masked_local}@{domain}"
```

---

## Dashboard Patterns

### Template Rendering
```python
from fastapi import Request
from fastapi.templating import Jinja2Templates

templates = Jinja2Templates(directory="app/templates")

@router.get("/dashboard")
async def dashboard(request: Request, db: AsyncSession = Depends(get_session)):
    metrics = await get_dashboard_metrics(db, days=7)
    return templates.TemplateResponse("dashboard/index.html", {
        "request": request,
        "metrics": metrics,
    })
```

### HTMX for Interactivity
Use HTMX attributes for modals, pagination, and inline updates:
```html
<!-- Pagination without full reload -->
<button hx-get="/dashboard/activity?page=2"
        hx-target="#activity-table"
        hx-swap="outerHTML">
    Next
</button>

<!-- Delete with confirmation -->
<button hx-delete="/api/suppressions/user@example.com"
        hx-confirm="Remove this email from suppression list?"
        hx-target="closest tr"
        hx-swap="outerHTML swap:1s">
    Remove
</button>
```

### Metrics Query Pattern
```python
async def get_dashboard_metrics(db: AsyncSession, days: int = 7):
    since = datetime.utcnow() - timedelta(days=days)

    total = await db.scalar(
        select(func.count()).where(Message.created_at >= since)
    )
    delivered = await db.scalar(
        select(func.count()).where(
            Message.created_at >= since,
            Message.status == "delivered",
        )
    )
    # ... etc for each metric

    return {
        "total_sent": total,
        "delivery_rate": round(delivered / total * 100, 1) if total else 0,
        # ...
    }
```

### Chart.js Daily Volume
```python
# Backend: aggregate by day
daily = await db.execute(
    select(
        func.date(Message.created_at).label("day"),
        Message.status,
        func.count().label("count"),
    )
    .where(Message.created_at >= since)
    .group_by("day", Message.status)
    .order_by("day")
)
```

```javascript
// Frontend: render Chart.js
const ctx = document.getElementById('volumeChart').getContext('2d');
new Chart(ctx, {
    type: 'bar',
    data: {
        labels: {{ days | tojson }},
        datasets: [
            { label: 'Delivered', data: {{ delivered_counts | tojson }}, backgroundColor: '#22c55e' },
            { label: 'Bounced', data: {{ bounced_counts | tojson }}, backgroundColor: '#ef4444' },
            { label: 'Deferred', data: {{ deferred_counts | tojson }}, backgroundColor: '#f59e0b' },
        ]
    },
    options: { responsive: true, scales: { x: { stacked: true }, y: { stacked: true } } }
});
```

---

## Testing Patterns

### Mock SES Client
```python
# tests/conftest.py
import pytest
from unittest.mock import AsyncMock

@pytest.fixture
def mock_ses_client():
    client = AsyncMock()
    client.send_email.return_value = "ses-message-id-123"
    return client
```

### Test Database
Use a separate test Postgres database or SQLite for speed:
```python
@pytest.fixture
async def db_session():
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    async with AsyncSession(engine) as session:
        yield session
```

### Integration Test Pattern
```python
async def test_send_email_full_flow(client, db_session, mock_ses_client):
    # 1. Send email
    response = await client.post("/api/emails/send", json={...})
    assert response.status_code == 200
    message_id = response.json()["messageId"]

    # 2. Verify DB record
    message = await db_session.get(Message, message_id)
    assert message.status == "sent"

    # 3. Simulate webhook
    webhook_payload = build_delivery_webhook(message.ses_message_id)
    response = await client.post("/api/webhooks/ses", json=webhook_payload)
    assert response.status_code == 200

    # 4. Verify status updated
    await db_session.refresh(message)
    assert message.status == "delivered"
```

---

## Config / Environment Variables

```bash
# Required
DATABASE_URL=postgresql+asyncpg://user:pass@localhost:5432/ses_email
AWS_ACCESS_KEY_ID=...
AWS_SECRET_ACCESS_KEY=...
AWS_REGION=us-east-1
SES_CONFIGURATION_SET=ses-assessment-tracking
SNS_TOPIC_ARN=arn:aws:sns:us-east-1:148761646433:ses-assessment-events

# Application
APP_BASE_URL=http://localhost:8000    # Used for tracking URLs and unsubscribe links
UNSUBSCRIBE_SECRET=your-secret-key    # For JWT signing
FALLBACK_REDIRECT_URL=https://example.com  # For invalid tracking IDs

# Safety guardrails
ALLOWED_EMAIL_DOMAINS=kubbly.com      # Comma-separated
EMAIL_RATE_LIMIT_PER_HOUR=15

# Optional
LOG_LEVEL=INFO
VERIFIED_DOMAIN=candidate-test.kubbly.com
```

---

## Common Pitfalls to Avoid

1. **SNS body parsing**: The request body arrives as bytes/string. FastAPI may not auto-parse it as JSON if the Content-Type header is `text/plain` (SNS does this). Use `await request.body()` and `json.loads()` manually.

2. **SES MessageId format**: SES returns MessageId with angle brackets in some contexts (e.g., `<id@region.amazonses.com>`). Strip them when storing.

3. **Async session scope**: Don't pass SQLAlchemy sessions across async boundaries or store them in global state. Each request gets its own session via `Depends(get_session)`.

4. **BeautifulSoup output**: `str(soup)` may slightly alter HTML (e.g., self-closing tags). This is fine for emails but test with real HTML to ensure nothing breaks.

5. **URL encoding in click tracking**: Use `urllib.parse.quote(url, safe="")` to encode the original URL. Use `safe=""` to also encode `/` — otherwise URLs with paths break the query parameter.

6. **Timezone consistency**: Store all timestamps as UTC. Use `datetime.utcnow()` or `datetime.now(timezone.utc)`. PostgreSQL `TIMESTAMP WITH TIME ZONE` stores everything as UTC.

7. **Idempotent webhook processing**: SES/SNS may deliver the same event multiple times. Check if the event already exists before inserting. Use the SNS `MessageId` as a dedup key.

8. **Content-Type for tracking pixel**: Return the GIF with `Content-Type: image/gif`, not `image/png`. The base64-decoded pixel is a GIF.

9. **HTMX + FastAPI**: For HTMX partial responses, check `request.headers.get("HX-Request")` and return only the partial template, not the full page.

10. **Rate limiting on tracking endpoints**: Click and open tracking endpoints will be hit by email clients (sometimes multiple times with prefetching). Don't apply strict rate limits to these — just dedup.

---

## Git Commit Convention
```
feat: description     # New feature
fix: description      # Bug fix
test: description     # Tests
docs: description     # Documentation
refactor: description # Code change (no new feature or fix)
chore: description    # Build, config, tooling
```

Make small, focused commits. Each phase from PLAN.md should be 1-3 commits.
